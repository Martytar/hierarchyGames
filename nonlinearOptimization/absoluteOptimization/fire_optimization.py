import random
import numpy as np

#Вообще говоря, метод только для конкретной задачи с 2 распределительными центрами (так как мы ровно половину параметров делаем зависимыми)

#будем использовать сверхбыстрый отжиг
def fire_optimization(F, B,  t0, t1, x): #f-целевая функция,t0 -изначальная температураб, x-начальная точка, B - верхние границы для параметров (нижние полагаем равными нулю)

    def h(df, T): #вероятностная функция принятия
        return np.exp(1)**(-1*df/T)

    t = t0
    c = 0.05 #к-т иземенения температуры (пока неуправляемый, потом поправлю для более точной настройки)
    x0 = x.copy()
    k = 0

    while t > t1 and k < 100_000:

        u = np.random.random(int(len(x)/2)) #генерируем равномерно распределенные величины для выбора новой точки
        y = np.zeros(int(len(x)/2))
        for i in range(0, int(len(y))):
            y[i] = np.sign(u[i] - 0.5)*t*((1+1/t)**(np.abs(2*u[i] - 1)) - 1) ##задаем смещения для новой точки

        x1 = x0.copy()
        for i in range(0, int(len(x1)/2)):
            x1[i] += y[i]*B[i]
            x1[int(len(x1)/2) + i] = B[i] - x1[i]
            if x1[i] > B[i]:  #В случае вылета за пределы ограничений просто берем границы
                x1[i] = B[i]
                x1[int(len(x1)/2) + i] = 0
            if x1[i] < 0:
                x1[i] = 0
                x1[int(len(x1) / 2) + i] = B[i]

        #получили смещенную точку, теперь проверим, лучше ли она предыдущей точки

        df = -1*(F(x1) - F(x0)) #так как ищем максимум, а не минимум, разность инвертируем
        if np.random.random() < h(df, t):
            x0 = x1
        print(x0)
        k += 1
        t = t * np.exp(1)**(-1 * c * k ** (1 / len(x)))  # итеративное изменение температуры


    return x0 #в качестве оптимального вектора